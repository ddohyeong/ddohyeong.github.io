---
title: 항목 60. @Transactional(readOnly = true) 의 실제 작동 방식
categories:
  - Spring
  - JPA
tags:
  - JPA
toc: true
toc_sticky: true
date: 2024-05-16
---
# 트랜잭션 컨텍스트란? 
> 데이터베이스 시스템이나 분산 시스템에서 트랜잭션이 발생하는 동안 유지되는 상태와 환경을 의미 

# @Transactional
> 메서드나 클래스에 적용하여 해당 메서드나 클래스에서 실행되는 모든 데이터베이스 작업이 트랜잭션 내에서 수행되도록 설정함 

🤔 트랜잭션 경계를 명시적으로 구분하고 전체 트랜잭션 기간 동안 하나의 DB 커넥션을 사용해야 한다? 
→ 모든 데이터베이스 작업ㅌ이 동일한 커넥션을 통해 수행되어야 한다는 것, 이를 통해 일관성과 무결성을 유지

## 트랜잭션 경계의 중요성
> 경계를 명시적으로 설정하는 것은 데이터베이스 작업의 일관성을 보장하는데 필수적이다. 

- 원자성 (A) : 모든 작업이 완전히 수행되거나 전혀 수행되지 않음을 보장
- 일관성 (C) : 트랜잭션이 완료되면 데이터베이스 상태가 일관성을 유지
- 격리성 (I) : 동시에 실행되는 트랜잭션들이 서로의 영향을 받지 않음
- 지속성 (D) : 트랜잭션이 성공적으로 완료되면 그 결과가 영구적으로 저장됨 

### 물리적 데이터베이스 트랜잭션이 뭘까?
- DBMS 에서 실제로 수행되는 트랜잭션을 의미한다. 
- 이는 논리적인 트랜잭션과 구분
- 데이터 베이스 커넥션
	- 물리적 트랜잭션은 특정 데이터베이스 커넥션을 통해 수행된다. 이 커넥션은 트랜잭션이 끝날때까지 유지

**🤔 왜 트랜잭션 격리 수준을 명시적으로 설정하면 예기치 않은 동작이 발생하는가?** 
많은 데이터 베이스는 기본 트랜잭션 격리 수준을 설정하고 있다. 특정 트랜잭션에서 기본값을 무시하고 명시적으로 설정하면 데이터베이스의 나머지 트랜잭션과도 충돌을 일으킬 수 있다.

이유는 트랜잭션 격리 수준과 애플리케이션 로직 간의 불일치가 발생함 
- 특정 트랜잭션 격리 수준이 설정되면 데이터베이스 동작 방식이 달라짐
- `READ COMMITTED`, `REPEATABLE READ`, `SERIALIZABLE` 등의 격리 수준은 각각 다른 방식으로 데이터 읽기와 쓰기를 처리합니다.
**auto-commit 모드와의 상호작용**
- auto-commit 이 true로 설정되면, 각 SQL문이 독립된 트랜잭션으로 실행되고 자동 커밋됨
	- 따라서 격리 수준을 명시적으로 하면 각 SQL문들이 각각 별도의 트랜잭션으로 처리되므로 격리 수준이 제대로 적용되지 않을 수 있다.

	- EX) `READ UNCOMMITED` 격리 수준을 설정한 트랜잭션은 다른 트랜잭션이 커밋하지 않은 변경 사항을 읽을 수 있다. 이는 문제(`Dirty Read`)를 발생 시킴 ( 조회 시점과 그 이후 시점이 달라지기 때문 )

**MYSQL의 기본 트랜잭션 격리 수준**
`Repeatable Read` 격리 수준임, 이 격리 수준은 다른 트랜잭션이 커밋한 변경 사항을 볼 수 없도록 함 
따라서 트랜잭션이 같은 데이터를 여러번 읽더라도 동일한 결과를 반환한다. 

이 트랜잭션이 데이터 일관성과 동시성 사이의 균형을 맞추는데 유리하다. → 그래서 사용하는 듯

---
## 단일 읽기 전용 SQL 문이 뭔데? 
> 데이터베이스에서 데이터 조회하는 SELECT문 , <mark style="background: #FFB8EBA6;">데이터의 변경이 없는 SQL문</mark>을 의미한다. 

### auto-commit = true 큰 이점을 가져오지 않은 이유
- 일기 전용 작업이기 때문에 데이터베이스 상태를 변경하지 않아도 됨
	- 따라서 트랜잭션 관리가 상대적 간단함
	- 일관성 문제난 충돌 가능성이 낮음 
	- 커밋이나 롤백의 개념이 중요치 않기 때문에
즉, 데이터 변경이 없기에 커밋 오버헤드가 없다. → 성능상 이점이 없다. 

### 따라서 명시적 트랜잭션이 좋다? 
- `auto-commit = true` 모드 사용대신 `@Transactional` 이 좋다는 뜻

🤔 명시적(선언적) 트랜잭션의 장점
1. **일관된 트랜잭션 관리**:
    - 명시적 트랜잭션을 사용하면 애플리케이션의 모든 데이터베이스 작업이 일관되게 관리됩니다.
    - 트랜잭션 경계를 명확히 지정할 수 있어, 코드의 가독성과 유지보수성이 향상됩니다.
2. **명확한 의도 표현**:
    - 트랜잭션이 명시적으로 선언되면, 코드에서 트랜잭션의 시작과 끝을 명확히 알 수 있습니다.
    - 이는 개발자에게 코드의 동작 방식을 명확하게 전달하며, 트랜잭션의 범위를 명확히 파악할 수 있게 합니다.
3. **예외 처리**:
    - 명시적 트랜잭션을 사용하면 예외가 발생했을 때 트랜잭션을 어떻게 처리할지 명확하게 정의할 수 있습니다.
    - `@Transactional` 어노테이션을 사용하면, 롤백 조건을 명확히 지정할 수 있어, 예외 처리 로직을 더 간단하고 명확하게 작성할 수 있습니다.

---
### 비 트랜잭션 컨텍스트란? 
> 명시적 트랜잭션 경계가 없는 컨텍스트를 의미, 즉 트랜잭션을 경계를 명시하지 않았을 때

이를 생락하면 해당 단점들이 애플리케이션에 노출됨 
1. auto-commit = false일 때 SQL 문이 JDBC 트랜잭션 내에서 실행되고 이후 커넥션을 닫음 
	- 이 때 <mark style="background: #FF5582A6;">트랜잭션은 닫지 않음</mark> 이 의미는 커밋되지 않은 상태로 남는 것 
	- 이러면 이후 커넥션 풀 또는 데이터베이스 벤더가 조치를 하는데 <mark style="background: #CACFD9A6;">일반적으로</mark> 트랜잭션 커밋, 롤백으로 트랜잭션으로 종료해야하기에 이런 상황은 위험함
2. 소규모 트랜잭션이 많은 경우
	- 모든 SQL 문에 대해 물리적 데이터베이스 컨텍스트가 시작하고 종료시 성능 오버헤드가 발생
3. 트랜잭션을 명시하지 않았을 ( 비 트랜잭션 컨텍스트 )때 개발자에 의해 데이터 write 로 변경되기 쉬움 
	- write 를 추가하면 안된다라는 것을 알리는 플래그 역할을 함
4. 데이터 엑세스 레이어에 대한 스프링 최적화 이점을 누릴 수 없다. 
	- 플러시 모드가 MANUAsL 로 설정됨 , 이는 더티 체킹 생략
5. 기본 설정으로 어노테이션이 `@Transactional`지정된 읽기 전용 스프링 내장 쿼리 메서드를 따를 수 없다. 
6. 읽기 전용 SQL 문에 대한 ACID 지원이 되지 않음
~~7. 하이버네이트5.2.10부터 커넥션획득을 지연시킬 수 있으며(항목60) 이를 위해 자동 커밋을 비활성화해야 한다.
	🚨 이거 갑자기 왜 나옴 
~~
🤔 결국 위와 같은 것들을 알고 있으면 `@Transactional (readonly = true)` 를 할지 안할지에 대해 결정에 도움이 됨 

# @Transactinal을 추가할 때 readOnly 설정을 false(기본값)으로 할까? 아님 true로 할까?

- 이 설정에 따라 <mark style="background: #FFB8EBA6;">Entity</mark>는 read-write 또는 Read-Only 모드가 됨
- 하이버네이트 내에서 차이점 발생
	- 하이드레이티드 상태인가 아닌가? 

**읽기-쓰기 모드**
> 엔티티와 하이드레이티드 상태 모두 사용

이는 영속성 컨텍스트 수명동안 또는 엔티티가 분리될 때 까지 사용됨
> [!tip] 흔히 잘 아는 더티 체킹 매커니즘이 사용됨 
> 

**읽기-전용 모드**
> 하이드레이티드 상태가 메모리에서 제거됨 

엔티티만 영속성 컨텍스트에 유지
따라서 자동 더티 체킹이나 낙관적 잠금 메커니즘이 비활성화 

엔티티는 Read-Only상태임


